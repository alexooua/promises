

<html lang="en">
<head>
    <meta charset="UTF-8">

</head>
<body>
<!--<script src="doAfter.js"></script>-->
<!--<script src="axios.js"></script>-->
<!--<script src="api-15.js"></script>-->

<script>
    // let promise = new Promise((resolve, reject) => {
// // Функция переданная в new Promise должна вызвать что-то одно: resolve или reject. Состояние промиса может быть изменено только один раз. Все последующие вызовы resolve и reject будут проигнорированы
//         resolve(1);
//         // reject();
//     });
//
//     promise
//         .then((message) => {
//             // этот колбэк вызовется когда промис завершится успешно (promise будет в        состоянии Resolved)
//             console.log('success: ', message)
//         })
//         .catch((err) => {
//             // этот колбэк выполнится когда промис завершится ошибкой (promise будет в состоянии Rejected)
//             console.log('err: ', err)
//         })
//         .finally(() => {
//             // этот колюбэк выполнится когда промис завершится: успешно или с ошибкой.
//             console.log('Промис завершён. Остановить индикатор загрузки')
//         })


    // 1111111111111111111
// // внутрь Promise передаем колбэк-функцию, которая собственно и есть та логика, которую промис обещает выполнить.
// let myPromise = new Promise((resolve) => {
//     alert('Hello');
//     resolve( )
// });
// // let a=()=>myPromise
//
// // ниже по коду мы можем подписаться, на промис, чтобы он (промис) вызвал нашу функцию, когда он (промис) зарезолвится. Для этого передаём в метод then колбэк-функцию)
// myPromise
//     .then(( ) => {
//     console.log("myPromise зарезолвился, и я узнал об этом")
//  })
// console.log(myPromise)



//          2222222222222222222222222222222222222222
//     2) А теперь перепишите свой промис, чтобы он обещал показать alert через 2 секунды (внутри промиса нужно вызвать setTimeout).
//     let myPromise = new Promise((resolve) => {
//         setTimeout(()=>{
//             alert('Hello')
//         resolve()
//         },2000)
//
//     });
//     myPromise
//         .then(( ) => {
//         console.log("myPromise зарезолвился, и я узнал об этом")
//      })



           // 3333333333333333333333333333333/
    // 3) В отдельном файле создайте новый промис, скопировав старый, а внутри пообещав показать в alert через 3 секунды  сгенерированное
    // рандомное число (с помощью Math.random)
    // let myPromise = new Promise((resolve) => {
    //     setTimeout(()=>{
    //         let a =Math.random()
    //         alert('Hello'+a)
    //         resolve()
    //     },2000)
    //
    // });
    // myPromise
    //     .then(( ) => {
    //         console.log("myPromise зарезолвился, и я узнал об этом")
    //     })
    //
    //

    // 44444444444444444444444
    // 4) Когда промис резолвится, он может отправить своим подписчикам какие-то данные, которые он там внутри своего колбека-обещания получил.
    // let myPromise = new Promise((resolve) => {
    //     setTimeout(()=>{
    //         let a =Math.random()
    //         // alert('Hello'+a)
    //         resolve(a)
    //     },2000)
    //
    // });
    // myPromise
    //     .then((a ) => {
    //         console.log("myPromise зарезолвился, и я узнал об этом = " +a)
    //     })



    //55555555555555555555555555555555555
    // 5) Чаще всего промис не создают как бы так просто, чтобы тут же на него подписываться. Чаще всего у нас есть какая-то функция, мы её вызываем, и она внутри себя создаёт новый промис и возвращает его нам (на подобие axios.get, axios.post и так далее)
    //
    // Давайте создадим функцию doAfter, которая:
    // 1. … принимает параметром кол-во секунд, сколько ждать
    // 2. … внутри себя будет создавать Promise, обещание которого - просто ждать переданное на этапе 1 кол-во секунд и резолвится через это время.
    // 3. ... возвращает созданный промис наружу.
// const doAfter=(sec)=>{
// let myPromise = new Promise((resolve) => {
//         setTimeout(() => {
//             // let a = Math.random()
//             // alert('Hello'+a)
//             resolve(a)
//         },sec*1000)
// return myPromise
//     });
// }
//
//     doAfter(5).then( () => console.log('я сработал через 5 секунд') );
//     doAfter(3).then( () => console.log('а я сработал через 3 секунд') );
//     doAfter(10).then( () => console.log('я сработал через 10 секунд') );



    //6666666666666666666666666
    // 7777777777777777777777777777
    // Что здесь происходит? Мы много раз подписались на событие ПРОМИС_ЗАРЕЗОЛВИЛСЯ, 3 раза обратившись к промису через метод then
    // Вопрос: 3 console.log() мы увидем одновременно или или каждый с задержкой в 3 секунды?
    const doAfter=(sec)=>{
        let myPromise = new Promise((resolve) => {
            setTimeout(() => {
                // let a = Math.random()
                // alert('Hello'+a)
                resolve(a)
            },sec*1000)
            return myPromise
        });
    }
    let promise3 = doAfter(3);
    promise3.then( () => console.log('я сработал через 3 секунд') );
    promise3.then( () => console.log('и я тоже следом сработал через 3 секунд') );
    promise3.then( () => console.log('и я') );
    // let p5=doAfter(5)
    // let p3=doAfter(3)
    // let p10=doAfter(10)
    // p5.then( () => console.log('я сработал через 5 секунд') );
    // p3.then( () => console.log('а я сработал через 3 секунд') );
    // p10.then( () => console.log('я сработал через 10 секунд') );

    //
// 888888888888888888888888888888888888888888888888888888
//     8) А если мы подпишимся на промис после того, как он зарезолвится?
//         Оберните подписку на промис в setTimeout c задержкой в 5 секунд.
//         В итоге промис зарезолвится через 3 секунды, а колбэк внутри setTimeout выполниться через 5 секунд.
//
//         Ответьте на вопросы:
//         1) Выполнится ли промис если он уже в состоянии resolved?
//         2) Если выполнится, то через какое время выполнится? (3, 5 или 8 секунд)
//     3) Что измениться если время которое считает setTimeout заменить с 5 секунд на 1 секунду
//     const doAfter=(sec)=>{
//         let myPromise = new Promise((resolve) => {
//             setTimeout(() => {
//                 // let a = Math.random()
//                 // alert('Hello'+a)
//                 resolve(a)
//             },sec*1000)
//             return myPromise
//         });
//     }
//     let promise3 = doAfter(3);
//
//     setTimeout(() => {
//         promise3.then( () => console.log('а я сработал через 3 секунд') )
//     },5000)


    // 99999999999999999999999999999999999999
    // 9) Что будет если внутри тела промиса вызывать setInterval каждые 5 секунд
    // Промис зарезолвится 1 раз или будет резолвиться новым значением каждые 5 секунд?
// let pr= new Promise(resolve=>{
//     let i=0
//     setInterval(()=>{
//         i++
//         resolve(i)
//         },5000
//     )
//     }
// )



    // 10000000000000000000000000000
    // 10) Промис - это объект, у которого есть 3 состояния и метод then
    // Метод = функция. Значит then - это функция. А возвращает нам что-либо эта функция? Да, возвращает НОВЫЙ ПРОМИС, который зарезолвится после того, как зарезолвится промис, then у которого мы вызвали.
    const doAfter=(sec)=>{
            let myPromise = new Promise((resolve) => {
                setTimeout(() => {
                    // let a = Math.random()
                    // alert('Hello'+a)
                    resolve(a)
                },sec*1000)
                return myPromise
            });
        }
    let pr1 = doAfter(3);
    let pr2 = pr1.then( () => console.log('Мой промис зарезолвился') );
    pr2.then( () => console.log('Мой промис тоже зарезолвился следом за pr1'));


<!--    pr1 - промис, который зарезолвится через 3 секунды-->
<!--    pr2 - промис, который во 2-ой строке кода породил метод then.-->
<!--        Важно: pr2 нам вернул не колбэк, который мы передали в then, а именно сам метод then нам вернул новый промис-->

<!--    Мы ничего не знаем про внутренности pr2, только то, что он зарезолвится после того, как зарезолвится pr1 и (внимание) отработает колбэк, переданный в then, из которого он вылез-->

<!--    Вопрос! Если мы вначале 3 строчки перед pr2.then допишем let something-->

<!--    let pr1 = doAfter(3);-->
<!--    let pr2 = pr1.then( () => console.log('Мой промис зарезолвился') );-->
<!--    let something = pr2.then( () => console.log('Мой промис зарезолвился следом за pr1'));-->

<!--    - Что будет в переменной something?-->
<!--        - Сколько у нас получиться промисов?-->


<!--        11) Цепочка из then-->
<!--    Благодаря тому, что then возвращает нам другой промис, мы можем выстраивать then в цепочку.-->
<!--        То что мы написали в примере выше, обычно пишут так:-->



<!--        Так как каждый then возвращает промис, мы можем бесконечно эту цепочку продолжать.-->
<!--        Пока учимся, будем писать КАЖДЫЙ пример в двух вариантах-->


<!--    12) Промис - это объект, у которого есть 3 состояния и метод then.-->
<!--        Каждый then возвращает новый promise, который резолвится после того, как зарезолвится промис, из then которого он вылез.-->

<!--        Зарефакторим, вынеся коллбэки в переменные:-->

<!--        let callback1 = () => console.log('Мой промис зарезолвился');-->
<!--    let callback2 = () => console.log('Мой промис тоже зарезолвился следом');-->

<!--    let pr1 = doAfter(3);-->
<!--    let pr2 = pr1.then(callback1);-->
<!--    pr2.then(callback2);-->

<!--    Важен 3 пункт! Потому что если callback1 что-то вернёт, то это что-то будет тем, чем зарезолвится pr2-->


<!--    13) Напишите код так, чтобы первый колбэк что-то вернул, и тогда pr2 зарезолвится этим и callback2 получит это что-то! Напишите сами!-->
<!--        В двух версиях!-->


<!--        14) Если писать через цепочку и при этом зафигачить в then-ы анонимные колбеки, то будет визуально понятнее, что куда прыгает (хотя может быть и неясно, что происходит внутри):-->





<!--    15) В новый файл добавьте этот код:-->


<!--        let pr = new Promise( (resolve) => {-->
<!--            let data = {-->
<!--                cities: [{title: "Minsk"}, {title: "Kiev"}],-->
<!--                website: "it-kamasutra.com"-->
<!--            };-->
<!--            resolve(data);-->
<!--        });-->

<!--    pr.then( data => {-->
<!--        console.log(data);-->
<!--    })-->
<!--        .then( website => {-->
<!--            console.log(website);-->
<!--        })-->

<!--    Доработайте этот код так, чтобы во втором колбэке второго then мы увидели “it-kamasutra.com”.-->
<!--    Перепишите этот код более детально, записывая каждый промис, возвращаемый из then в отдельную переменную.-->


<!--    16) Создайте новый файл и подключите в него этот фейковый axios.js, который умеет делать get-запросы и post-запросы, и api.js-->


<!--    <script src="axios.js"></script>-->
<!--<script src="api.js"></script>-->

<!--<script>-->
<!--    api.sendStudentsCountToItKamasutra(20)-->
<!--        .then(res => {-->
<!--            console.log(res);-->
<!--        });-->
<!--</script>-->
<!--Посмотрите в консоли, какой результат нам вернётся. Много лишнего апишка нам возвращает, хотелось бы просто получить от неё объект с данными.-->

<!--Переделайте по аналогии с предыдущим примером так, чтобы апишка нам возвращала другой промис, который зарезолвится не всем объектом, а только тем, что нужно! Переделайте также 2 других метода-->


<!--17) Мы можем получить обещание, которое выполнится, когда все под обещания будут выполнены.-->
<!--Техническими словами: некоторый общий Promise зарезолвится, когда зарезолвятся все другие входящие в него Promise-ы-->

<!--let pr1 = doAfter(4); // один промис-->
<!--let pr2 = doAfter(7); // второй промис-->

<!--pr1.then( () => console.log("pr1 resolved") ); // индивидуально подписываемся на каждый-->
<!--pr2.then( () => console.log("pr2 resolved") );-->

<!--let aggregatedPromise = Promise.all([pr1, pr2]); // получаем общий промис-->

<!--aggregatedPromise.then( () => console.log("pr1 and pr2 resolved")); // сработает наш подписчик ТОЛЬКО когда все промисы, переданные в массиве в all будут resolved-->





<!--18) А теперь по аналогии с doAfter создайте функцию (копипастом)-->
<!--getRandomAfter, которая будет рандомно выдавать какое-то число через заданное кол-во секунд-->


<!--getRandomAfter(4).then( number => console.log(`я получил ${number} спустя 4 секунды`))-->

<!--А потом давайте напишем так:-->


<!--let promises = [getRandomAfter(1),getRandomAfter(2), getRandomAfter(3)];-->
<!--let commonPromise = Promise.all(promises);-->
<!--commonPromise.then( () => {-->
<!--// как вывести здесь все 3 числа?? гуглим Promise.all-->
<!--} );-->


<!--19) А это пример из жизни:-->


<!--api.getVacanciesCountFromMicrosoft()-->
<!--.then(data => {-->
<!--console.log(data);-->
<!--});-->

<!--api.getVacanciesCountFromGoogle()-->
<!--.then(data => {-->
<!--console.log(data);-->
<!--});-->

<!--api.sendStudentsCountToItKamasutra(XXXX)-->
<!--.then(data => {-->
<!--console.log(data);-->
<!--});-->

<!--Нужно в камасутру отправить суммарное кол-во вакансий значение, которое получится в ответах от компании microsoft и google-->



<!--20) Что будет если из промиса возвращать не какое то значение (примитив или объект), а  промис?-->

<!-- - Если из колбэка возвращается какое-либо значение, то это значение придет параметром в следующий колбэк. См скриншот-->




<!-- - Однако если из колбэка возвращается промис, то в следующий колбэк придет не промис, а значение, которым этот промис зарезолвится.-->


<!--21) Async, await-->

<!--Синтаксис async/await позволяет избавиться от колбэков, которые мы передаем в then и сделать наш код линейным и более читаемым.-->

<!--До сих пор мы дожидались пока промис зарезолвиться с помощью метода then, а используя синтаксис async/await мы дожидаемся промиса с помощью await.-->

<!--let res = await api.getTodolists()-->


<!--Await разрешается писать только в асинхронных функциях т..к. они умеют прерываться и дожидаться асинхронного ответа (ответа от сервера). Т.е. пока ответ с сервера не придет строка следующая за await не будет выполнена-->

<!--Чтобы  сделать функцию асинхронной нужно просто перед ней написать async-->






<!--Примеры:-->

<!--Thunk c использованием then-->


<!--Thunk c использованием async/await-->


<!--21) Обработка ошибок try/ catch-->

<!--Конструкция try...catch пытается выполнить инструкции в блоке try, и, в случае ошибки, выполняет блок catch.-->








//промисификация
//  const doAfter=(s)=>{
//      let myPromise = new Promise((resolve,reject) => {
//          setTimeout(() => {
//              const randomV = Math.random()
//              resolve(randomV)
//          }, s*1000)
//      })
//      return myPromise
//  }
//     // ниже по коду мы можем подписаться, на промис, чтобы он (промис) вызвал нашу функцию, когда он (промис) зарезолвится. Для этого передаём в метод then колбэк-функцию)
//  doAfter(5).then( () => console.log('я сработал через 5 секунд') );
//  doAfter(3).then( () => console.log('а я сработал через 3 секунд') );
//  doAfter(10).then( () => console.log('я сработал через 10 секунд') );
//  let promise3 = doAfter(1);
// //
//  let pr = new Promise( (resolve) => {
//      let data = {
//          cities: [{title: "Minsk"}, {title: "Kiev"}],
//          website: "it-kamasutra.com"
//      };
//      resolve(data);
//  });
//
//  pr.then( data => {
//      console.log(data);
//  })
//      .then( website => {
//          console.log(website);
//      })
</script>
</body>
</html>
